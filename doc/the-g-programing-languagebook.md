# The G Programming Language : Book
written by Pouya mohammadi.










> This book use v5.7.6 of glang interperter, pleases see ![this page](https://github.com/glang/doc/the-g-programming-langugae-book/last.pdf) to get last version of current book.

> این نخسه فارسی این کتاب است






# مقدمه
همه ی ما میدانیم امروزه پیدا کردن زبان برنامه نویسی که هم ساده باشد هم کارامد سخت شده و حتی غیر ممکن, شروع ماجرا دقیقا از همین جاست. جی زبانی هست که سعی کرده راحتی قدرت سایز کم یا همون مینمال بودن و محافظت از داده ها و ... رو حفظ کنه 
البته که ساخت همچین چیزی وقت زیادی رو طلبیده ولی اکنون جی واقعا می تونه جایگاه بزرگ و خاصی توی دنیا زبان های برنامه نویسی پیدا کنه.

همین تو از والتر برایت بابت نصیحت های که من رو کردم تشکر می کنم و همواره سعی می کنم به ان ها عمل کنم.

# فهرست

هنوز این بخش کامل نشده!

# بخش ۱ \ شروع کار

بیاید با نصب جی شروع کنیم پروسه ای که نه زمان بر هست و نه وقت گیر (البته فقط برای جی!)

خب ما دو روش برای نصب جی داریم
> هنوز من نخسه های از باینری کمپایل شده توی زمان نگاشت این کتاب برای معماری های دیگر نساخته ام فقط یک معماری پشتیبانی میشود : x86 ۶۴ بیتی.

روش اول که ساده ترین هم هست نصب باینری هست
روش دوم هم که کمپایل از سورس هست.

توی روش اول ما خیلی راحت وارد سایت ![glang](https://glang.ct.ws/) میشیم و روی دکمه ی دانلود که همون دکمه قشنگه و پر از css هست کلیک می کنیم که ما رو به صفحه ی گیت هاب و رلیس های جی می بره و ما با کلیلک روی فایل که اسمش "glang" هست اون رو دانلود می کنیم
این فایل یه باینری هست که بغد از دانلودش برا اجراش لازمه بهش دسترسی بدیم با دستور
```bash
chmod +x glang
```
دسترسی به فایل باینری میدیم یعنی یه جورای مثل این می مونه که بگیم به سیستم که نگاه! این یه فایل اجرای هست.

بعدش هم که خیلی راحت اجراش می کنیم ‍‍```./glang -v```

خب فقط یه کار میمونه باید اون رو به پوشه ی /usr/bin ببریم تا بتونیم همه جا ازش استفاده کنیم با دستور زیر:

```bash
sudo cp glang /usr/bin
```
این بخش کارمون هم انجام میشه.
چون دسترسی به این پوشه برای کاربر عادی مثل منو شما امکان پذیر نیست از sudo استفاده می کنیم.

خب تا اینجا که این روش اسون ما بوده
ولی همون طور که گفتم بعضی وقتا لازمه که جی رو روی یه پلتفرم دیگه با معماری دیگه اجرا کرد یا نخسه باینری قدیمی هست و می خواهید به نخسه ی جدید تری دسترسی داشته باشید.

پس اگر شما از دسته ی دوم هستید که نخسه ی باینری قدیمی هست لطفا توی بخش issue گیت هاب به ما بگید.

خب بیاید بریم سراغ کمپایل.

اول از همه چیز نیاز به سورس کد داریم برای این کار می تونیم از git استفاده کنیم

‍‍‍```bash
git clone https://github.com/pouyathe/glang
```
خب با کد بالا پوشه ای با نام glang ساخته میشه که همه چیز توش هست.
بیاید وارد اون پوشه بشیم
```bash
cd glang/
```
خب نترسید! درسته اینجا پر از فایل هست اونا رو بیاید نادیده بگیریم و بریم به پوشه ی سورس.
```bash
cd source
```
خب اینجا به انتخاب های میرسیم هنوز بخش cmake کامل نشده توی الان که این کتاب رو می نویسم ولی بخش dub بهترین و بروز ترینش هست.
oda هم پروجکت منیجر و بیلدری هست که خودم نوشتم اگر از اون استفاده می کنید فقط کافیه فایل glang_foroda.oda رو دانلود کنیم.

همون طور که گفتم هنوز cmake کامل نیست پس از dub استفاده می کنم.

خب بیاد بریم به پوشه ی dub
```bash
cd dub
```
الان فقط کافیست که dmd روی سیستم ما نصب باشه اگر نیست از:

‍‍‍```bash
# for ubuntu
sudo apt install dmd
sudo snap install dmd
# for fedora
sudo dnf install dmd dub
# RHEL/CentOS 8+
sudo dnf config-manager --add-repo https://dlang.org/rpm/$(rpm -E %dist).repo
sudo dnf install dmd dub
# From official repos
sudo pacman -S dlang-dmd dub

# Or from AUR (newer versions)
yay -S dmd-bin dub-bin
# Add repository
sudo zypper addrepo https://download.opensuse.org/repositories/devel:languages:D/openSUSE_Leap_15.4/ dlang
sudo zypper refresh

# Install
sudo zypper install dmd dub
# Enable community repo
echo "http://dl-cdn.alpinelinux.org/alpine/edge/community" >> /etc/apk/repositories

# Install
apk add dmd dub
# Temporary installation
nix-shell -p dmd dub

# Permanent in configuration.nix
environment.systemPackages = with pkgs; [ dmd dub ];
# Install
sudo xbps-install -S dmd dub

# Verify
dmd --version
# Emerge
sudo emerge -av dev-lang/dmd app-misc/dub

# Verify
dmd --version
```
اگر لینوکسی که شما استفاده می کنید توی لیست نیست از بخش issue گیت هاب به ما اطلاع بدید.

چون g با D نوشته شده لازمه با خود دی کمپایل بشه.

بعد از نصب dmd , dub ; توی پوشه "dub" اسکریپت زیر رو بنویسید:
‍‍```bash
dub
```
این دستور براتون کار کمپایل رو انجام میده و بغدش به شما فایل باینری جی لانگ رو تحویل میده
و اگر خواستید می تونید اون رو به /usr/bin ببرید تا از همه جا بهش دسترسی داشته باشید.

## بخش ۲ / بخش ها

الان که موفق شدید که جی رو نصب کنید و مطمعن شدید کار می کنه وقتش هست که یکم درباره جی بهتون بگم.
مفسر جی از یه قاعده ی خاصی پیروی می کنه که من نوشتم و اسمش رو گذاشتم "کد تمیز و ساده
"
این گونه هست که مفسر فقط دنبال یک چیز می گرده بخش کد.

بزارید براتون بهتر توضیح بدم اگر اسمبلی نوشته باشید می دونید که در اسمبلی فایل از بخش های تشکیل شده.
زمانی که من روی یه سیستم عامل ۱۶ بیتی اجرا شونده در حالت واقعی کار می کردم فایل اسمبلی من از ۲ بخش تشکیل شده بود :‌ بخش کد و بخش دیتا و توی ۱۶ بیت حافظه ی رزرو شده درون بخش دیتا ها بود و دیتا ها همون استرینگ ها بودند با این فرق که باید اخرشون یک صفر به معانی اخر استرینگ بزاری چون اسمبلر متوجه نمی شد تا کجا استرینگ ادامه داره و پایانش کجاست و کجا باید به ایسته.

مثل همون اسمبلی فایل های جی هم همین طوری هستند ولی فقط بخش ساخته شدن بخش کد.
چرا می گم فقط یک بخش؟ چون در جی نمی توانی هم فانکشن بسازی یا به عبارتی نمی تونی هم بخش کد داشته باشی هم بخش فانکشن

یا باید اون فایل فایل اجرای باشه یا فقط فایل فانکشن باشه.

و توی هر فایل فقط ۱ فانکشن میشه ساخت که همین هم باعث هم خوانایی بهتر پروژه میشه (لازم نیست برای پیدا کردن اون فانکشن یه فایلی که از هزاران فانکشن تشکیل شده رو بخونیم
)
هم باعث میشه فایل های جی سایز خیلی کمی داشته باشن.

بیاید وارد بخش عملی بشیم.
خب قاعده ما این هست که اول ما باید یاد بگیریم که چطور یه بخش بسازیم تا مفسر متوجه اون بشه.
۲ . چطور به مفسر بگیم که بعد اتمام اون بخش چهکار کنه

تعریف بخش خیلی ساده هست ولی باید برخی قوانین رو بدونیم
۱. مفسر فقط بخش های استاندارد رو می خونه به عبارنی با ید به مفسر بگیم : هدف مفسر فقط رد شدن از این فایل امام من باید نظرشو جلب کنم
این من رو یاد وقفه ها توی سی پی یو میندازه که توی پردازنده در خا انجام کلی کار دیگه هست و با وقفه شما بهش میگید : هی وایستا اول کار من رو بکن بعد هر کاری رو که میخوای.
۲. مفسر بعد از خوندن اون بخش نمی دونه باید چیکار کنه ما باید بهش بگیم که چی کار کنه.
۳. مفسر فقط کد درون بخش کد رو می خونه کد درون بخش فانکشن به همین خاطر اجرا نمیشه

خب پس چطور بخش استاندارد بسازیم؟ خب از اون جای که جی زبان راحتی هست این هم کاری نداره!

۱. همه ی بخش های استاندارد با شروع میشن ‍‍‍```std.<نوع بخش> ```
> نکته : از اون جای که خودتون هم متوجه شدید امکان ساخت بخش سفارشی وجود نداره بعضا هم اگر بسازید یا خطا هست یا اصلا اون بخش خونده نمیشه به عبارتی مفسر تنبله و فقط می خواهد از فایل رد شه و اگر بخش کدی وجود داشته باشه نظرش جلب میشه

۲. همه ی بخش های استاندارد باید با ‍‍```std.exit``` تموم بشن و بعدش باید به مفسر بگید چه کار کنه
> شما تنها با برنامه ی که تموم شده بخش کدش می تونین خارج بشین حالا با خطا یا بی خطا

خب بیاید یه مثال ازش ببینیم
```g
std.main:
    std.echo "Hi"
    ln
std.end: exit N
```
خب همونطور که دیدید شروع برای نوشتن هر بخش با ":" شروع میشه
و می بینید خود std.end هم از فنی هم یه جورای یه بخش جدا برا خودشه ولی از سینتکس لامبدا (نوشتن همه چیز توی یه خط) استفاده می کنه

و من فقط می تونم یه کار بکنم بعد اتمام بخش کد مفسر همونطور که گفتم تنبل هست نمیاد وقت خودش رو برای یه بخش هدر بده تا ابزار فایلش دیتا ورودی/خروجی و ... خودش رو دوباره صدا بزنه اما فقط یه کاری رو توی بخش اخر می کنه اینکه از برنامه خارج بشه.

N همون Normal خودمون هست یعنی برنامه بدون خطا خارح میشه
بزارید یکم این رو توضیح بدم این به ترمینال این سیگنال رو میده که اره این برنامه هیچ خطای نداشت.

برعکس همین هم هست E که مخخف Error هست.
و به ترمینال این سیگنال رو میده که اجرای این برنامه خطا داشت.

بزارید برای این هم یه مثال بهتون نشون بدم

```g
std.main:
    std.echo "Ho"
    ln
std.end: exit E
```
خب حالا که این رو فهمیدیم بیاید درباره بخش فانکشن حرف بزنیم

اول لازمه ما اسمی برای اون فانکشن بزاریم که توی جی اسمش می تونه هر کاراکتری باشه (مفسر تنبله)
و ما از ```fn``` هم برای ساخت فانکشن استفاده می کنیم هم برای صدا زدنشون

> شاید ندونید فانکشن چیه مشکلی نیست منم این شما خب وقتی کلاس ۷ هم بودم و برنامه نویسی رو شروع کردم نمی دونستم!
فانکشن ها بخش های از کد هست که کدی رو ذخیره می کنن تا ما لازم نداشته باشیم اون ها رو از اول بنویسیم و هم انعطاف پذیری و هم زمان و زیبایی کد از دست بره
فرض کنید من فرمول فیثاغورس رو توی جی نوشتم و الن کد مثلا ۲۰ خط هست و من یه فایل دیکه ای دارم که توش مساعل مربوط به فیثاغورس هست من هم بیام از اول فیثاغورس رو تعریف کنم هم سخته هم وقت گیر به جاش میام به فانکشن تبدیل می کنم و مقدار رو بهش می دم و بهم بر می گردونه جواب رو

خب بیاید یه مثال بزنیم از این
```g
fn hello_func
    std.echo "type your name my friend :"
    glue string
    get_n
    std.echo "Hello "
    fecho %
    ln

```
شاید بخش های از کد رو ندونید نگران نباشید من هنوز اون ها رو بهتون نگفتم و انتظار هم ندارم شما الان یادش بگیرید ما بعدا دربارشون صحبت می کنیم

خب یه نکته ای هست اونم اینکه بخش فانکشن نیازی به بستن نداره چون
۱. استاندارد نیست مفسر قرار نیست اون رو بخونه تا اجرا کنه
۲. اون رو به کد اصلی اضافه می کنه مثل C

## بخش ۳ / داده ها

خب بیاد به یک بخش دیگر از جی بپردازیم داده ها.
در نظر بگیرید جی دنبال کد تمیز و قابل ویرایش راحت و مجدد هست و فلسفه اون هم همین هست برخلاف دیگر زبان ها.

خب ما در کل در جی چنتا نوع داده داریم :‌
rea : همون پول خودمون
int یا @ : اعداد
٪ : رشته ی متنی
float : اعداد اعشاری
address : هم حافظه ی رم گرفته شد و هم ادرس اون حافظه در رم (malloc)
bi :  اعداد خیلی بزرگ
و برخی کتاب خانه ها نوع خاصی از دیتا ها دارند اما بیشتر یه نوع برچسب برای یکی از همین داده هاست

یه چیز خیلی مهمی هست که ما در جی باید صد در صد بدونیم :‌ هر نوع داده یه متغییر جهانی دارن بعضی بعضی از اون ها فقط از همین طریق در دسترس هستند

بیاید کمی بیشتر وارد این موضوع بشیم اگر اسمبلی نوشته باشید می دونید چیزی داریم به نام ریجیستر که درون سی پی یو هست و سرعت خیلی بالای داره جی هم از چیزی شبیه این استفاده می کنه که همون فلسفه ی تمیزی کد رو دنبال می کنه

و بیشتر فانکشن های درون جی از همین متغییر های جهانی استفاده می کنن
شما بهتره از همین متغییر ها توی فانکشن ها استفاده کنید مگر این که از برچسبش استفاده کنید

خب بیاید با چگونگی تعریف یه فانکشن به پردازیم : 
‍```g
std.main:
    [%] : "Hello world"
    [__rea__] : 0.05
    [__float__] : 1.038
    [__bi__] : 1937937469274836476767577398494759385
    [__string__] : "it will change global string."
    [@] : 17
    [%], 2hi8j : "this not change global string it be new string"
    fecho %
    ln
std.end exit N
```
یه بحث دیگری هم هست ... برخی فانکشن ها از گرفتن متغییر پشتیبانی می کنند نه همه ی انها برای مثال
```g
std.echo
```
از گرفتن متغییر پشتیبانی نمی کنه اما برادر ان
‍‍‍```g
fecho % یا std.format.echo %
‍‍‍‍‍```
فقط از گرفتن متغییر پشتیبانی میکنه نه از چرفتن استرینگ از طریق تایپ توی اون.

خب همونطور که دیدید اسم اون متغییر اگر سفارشیش می کنیید اهمیتی نداره و می تونه همه چیز باشه که این پیرو فلسفه ی راحتی در جی هست
و در ضمن همه ی متغییر ها هنوز از اسم گذاری پشتیبانی نمی کنن

و برای هر متغییر اسم گیر می تونید ۱۰ تا اسم شفارشی بسازید نه بینهایت

به عنوان یک مثال ```get_n``` جواب و اون چیزی که از کاربر گرفته رو در متغییر جهانی استزینگ ذخیره می کنه

شما لازم نیست متغییر جهانی رو تعریف کنید اون همیشه تعریف شده هست

همه ی داده ها قابل عوض شدن هست چیزی در جی برای محدود کردن استرینگ ها فعلا وجود نداره یعنی همه مقدارشون قابل عوض شدن هست

## بخش ۴ \ ریاضی
میرسیم به بخش شیرین ریاضی که شاید هم برای برخی ها زیاد شیرین نباشه و بیشتر ترش یا شور باشه! البته بگذریم :)

خب توی جی ما روی دو چیز می تونیم عملیات ریاضی انجام بدیم:
۱. پول 
۲. اعداد

خب بیاید با پر کاربرد ترینشون یعنی اعداد شروع کنیم

توی جی همیشه دو نکته هست
‍۱. همیشه انجام ریاضی روی متغییر جهانی انجام میشه
۲. هر عملیات ریاضی علامت خودشو داره و از سمت چپ شروع میشه

```g
std.main:
    [@] : 2
    [@] : + 1
    [@] : - 1
    [@] : * 3
    [@] : \ 3
    int.echo @
    ln
std.end: exit N
```
```
pouya@pouya-Latitude-E5440:~$ glang -c math.g
2
pouya@pouya-Latitude-E5440:~$ 
````

جواب من که شد ۲ خودتون هم اجراش کنید ببینید جواب شما چنده!

خب پس چهار تا عملیات داریم :‌
۱.+ :‌جمع
۲. - :‌منهای
۳. * :‌ ضرب
۴. \ :‌تقسیم

> نکته : این عملیات ها اینجوری کار میکنن 
> global number + 4
> global number * 2

حالا بیاد درباره پول صحبت کنیم
توی جی برای پول متغییر مخصوصی وجود داره که اون رو برای استفاده توسط سرویس های بانکی عالی می کنه 

```g
std.main:
    [__rea__] : 0.3
    rea_add 0.4
    fecho __rea__
    ln
std.end: exit N
```
```
pouya@pouya-Latitude-E5440:~$ glang -c math.g
0.7
pouya@pouya-Latitude-E5440:~$ 

```
خب برای من هم که شد ۰.۷ 
حتما حتما حتما خودتون هم اجراش کنید تا یاد بگیرید

## بخش ۵ \ حلقه ها

فعلا جی هنوز در حال شکل گیری هست و هنوز بعضی چیزا رو نداره اما هنوز هم به نظرم ارزشو داره.

بیاید به حلقه ها نگاهی بندازیم
ما تو جی یه جورای هم foreach داریم و هم نداریم
بیاید به جورای تکنیک ساختشو بلد باشیم

توی جی ما از ```lwhile``` استفاده می کنیم تا یه فایل جی رو بر اساس مقدار متغییر جهانی عدد اجرا میکنه
> گول اسمشو نخورید ! این قرار نیست اگر شرطی برقرار بود فایل رو اجرا کنه

```g
std.main:
    [@] : 10
    lwhile helloworld
std.end: exit N
````

نباید اسم فایل رو با .g بدید چون مفسر به هر فایل جی به نگاه یکی از اجزای جی نگاه می کنه
و می تونید با استفاده از / و همون سیستم ادرس دهی استاندارد لینوکس اگر فایل تو پوشه ای هست اجراش کنید

## بخش ۶ / صفحه

به این بخش رسیدیم بخش صفحه . بیاید یکم بیشتر بهش بپردازیم چون خالی از لطف واقعا نیست

خب بیاید شروع کنیم

G از سه روش چاپ روی صفحه ی ترمینال استفاده میکنه
همون طور که گفتم فانکشن ها یا متغییر پذیرند یا نه من هم می خواهم همین بخش رو برای استرینگ ها بیان کنم
```g
std.main:
    std.echo "Hello world"
    ln
    [%] : "Hello"
    fecho %
    ln
std.end: exit N
```

ln : همون "\n" خودمون هست برای تازه کار ها همون خط جدید سازه

حالا اگر بخواهیم یک عدد رو چاپ کنیم چنتا راه داریم

۱. مثل استرینگ استفاده کنیم 
```g
std.main:
    std.echo "2"
    [%] : "4"
    fecho %
    ln
std.end: exit N
``` 
این روش فقط توی چاپ به درد می خوره چون نمی تونیم از این عدد درون ایترینگ برای عملیات های ریاضی استفاده کنیم
۲. از خود اعداد استفاده کنیم

```g
std.main:
    [%] : 23
    int.echo @
    ln
std.end: exit N
```
با این روش خود اعداد چاپ میشن و می تونیم راحت ازشون استفاده کنیم

گرفتن خروجی رنگی در ترمینال:
توی جی مثل همیشه این هم راحته ما از ```glue``` استفاده می کنیم

```g
std.main:
    glue gcolor

    fcolor __gcolor__:blue
    std.echo "Hi"
    ln
    fcolor __gcolor__:system
std.end: exit N
```

```gcolor``` به ما امکان پرینت رنگی رو میده

